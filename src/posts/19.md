---
title: The Glodot is real!
description: '"Can we get much higher?"'
tags:
  - gleam
  - godot
  - game_dev
date: 2025-07-19
image: https://i.imgur.com/mduNOpT.webp
---

## What?

{% if lang == 'vi' %}
  **Glodot** == [Godot](https://godotengine.org) + [Gleam](https://gleam.run). N√≥ l√† c√°ch ƒë·ªÉ ch·∫°y code Gleam trong Godot.
{% else %}
  **Glodot** == [Godot](https://godotengine.org) + [Gleam](https://gleam.run). It's a way to run Gleam code inside Godot.
{% endif %}

## Who?

{% if lang == 'vi' %}
  _"Ai nghƒ© ra c√°ch n√†y?"_ - M√¨nh nghƒ© ra c√°ch n√†y!

  _"Glodot ph√π h·ª£p cho ai?"_ - Cho nh∆∞ng ng∆∞·ªùi th√≠ch [FP (Functional programming)](https://vi.wikipedia.org/wiki/L%E1%BA%ADp_tr%C3%ACnh_h%C3%A0m) v√† mu·ªën d√πng n√≥ cho gamedev.
{% else %}
  _"Who discover this?"_ - Me!

  _"Glodot is for whom?"_ - It's for people who like [FP (Functional programming)](https://en.wikipedia.org/wiki/Functional_programming) and want to use it for gamedev.
{% endif %}

## When/where?

{% if lang == 'vi' %}
  Vi·ªác s·ª≠ d·ª•ng Glodot tr·ªü n√™n r·∫•t l√Ω t∆∞·ªüng khi ta c·∫ßn vi·∫øt thu·∫≠t to√°n v√† x·ª≠ l√Ω c√°c th·ª© b√™n trong [Domain logic](https://en.wikipedia.org/wiki/Business_logic), s·ª≠ d·ª•ng Gleam k·ªÉ c·∫£ khi vi·∫øt code ƒë∆°n gi·∫£n nh∆∞ x·ª© l√≠ h√†nh ƒë·ªông vu·ªët cho [game 2048](https://play2048.co) c≈©ng tr·ªü n√™n d·ªÖ th·ªü h∆°n ch√°n v·∫°n so v·ªõi GDscript.

  Tuy nhi√™n, ch·ª© n√≥ kh√° l√† kh√≥ ƒë·ªÉ t∆∞∆°ng t√°c tr·ª±c ti·∫øp v·ªõi node tree b√™n ngo√†i domain logic, nh∆∞ x·ª≠ l√Ω v·∫≠t l√Ω ch·∫≥ng h·∫°n...
{% else %}
  Glodot is ideal for [the domain logic](https://en.wikipedia.org/wiki/Business_logic) (like writing complex algorithms). Even for simple stuff like handling result from swipe gestures in a [2048 game](https://play2048.co), writing in Gleam is way more breathable compared to GDScript.

  However, it's hard to interacts directly outside of domain logic from the Gleam code (like interacts heavily with the node tree and handling physics for exmaple)...
{% endif %}

## Why?

{% if lang == 'vi' %}
  Godot l√† m·ªôt game engine x·ªãn nh∆∞ng GDscript th√¨ kh√¥ng h·∫≥n, n√≥ kh√¥ng t·ªët b√™n trong domain logic. V√† C# c√≥ t·ªët h∆°n nh∆∞ng kh√¥ng ƒë·ªß t·ªët nh∆∞ m·ªôt ng√¥n ng·ªØ FP h·∫≥n hoi.

  Gleam l√† m·ªôt s·ª± c·ª©u th·∫ø, l√† m·∫£nh gh√©p ho√†n h·∫£o cho s·ª± thi·∫øu h·ª•t c·ªßa Godot. Syntax c·ªßa n√≥ ƒë·∫πp, hi·ªán ƒë·∫°i m√† l·∫°i quen thu·ªôc, n√≥ d·ªÖ ƒë·ªçc, d·ªÖ qu·∫£n l√Ω v√† d·ªÖ h·ªçc (c√≥ th·ªÉ h·ªçc ch·ªâ trong m·ªôt ng√†y), kh√¥ng ch·ªâ th·∫ø tooling c·ªßa n√≥ c√≤n r·∫•t ti·ªán, ti·ªán h∆°n c·ªßa Lua, Python, C#...

  V√¨ th·∫ø n√™n ƒë√¢y l√† t·ªï h·ª£p ho√†n h·∫£o:
  - GDscript ƒë·ªÉ ti·ªán cho vi·ªác x·ª≠ l√Ω t∆∞∆°ng t√°c v√† v·∫≠t l√Ω v·ªõi "th·∫ø gi·ªõi th·ª±c".
  - Gleam ƒë·ªÉ vi·∫øt cho domain logic functions v·ªõi input/output ƒë√£ ƒë·ªãnh s·∫µn, cho c√°c thu·∫≠t to√°n ho·∫∑c t√≠nh to√°n ph·ª©c t·∫°p.
{% else %}
  Godot is a great game engine but GDscript is not a good language to do domain logic stuffs. And yes, C# is better but not as good as a real FP langauge.

  Gleam is the savior that fill the gap in the Godot ecosystem. Its syntax is beautiful, modern, familiar, easy to read, to manage and to learn (can be learn in a day). Plus Gleam's tooling is convenient, more than its of Lua, Python, C#...

  Therefore, this is the perfect combination:
  - GDscript for convenient "real world" interactions and handle physic.
  - Gleam for writing domain logic functions with predefined input and output, like complex algorithms/calculations.
{% endif %}

## How?

{% if lang == 'vi' %}
  Con ƒë∆∞·ªùng k·∫øt n·ªëi Godot v·ªõi Gleam ƒëi nh∆∞ sau:

  - **[Godot Mono](https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_basics.html):** ƒê·ªÉ ch·∫°y ƒë∆∞·ª£c code C# trong Godot.
  - **[ClearScript](https://github.com/Microsoft/ClearScript):** ƒê·ªÉ ch·∫°y ƒë∆∞·ª£c code Javascript trong C# [(v√† ƒë√¢y l√† c√°ch ƒë·ªÉ d√πng NuGet packages trong Godot)](https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_basics.html#using-nuget-packages-in-godot).
  - **[Bun](https://bun.sh) ho·∫∑c b·∫•t c·ª© JS bundler n√†o:** ƒê·ªÉ bundler nhi·ªÅu file JS v√†o th√†nh m·ªôt.
  - **[Gleam compiler](https://gleam.run/command-line-reference):** ƒê·ªÉ compiler code x·ªãn vi·∫øt b·∫±ng Gleam üòâ.
{% else %}
  The road to connect from Godot to Gleam is as follows:

  - **[Godot Mono](https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_basics.html):** To use C# in Godot.
  - **[ClearScript](https://github.com/Microsoft/ClearScript):** [_Use that NuGet package in Godot_](https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_basics.html#using-nuget-packages-in-godot) to run Javascript code in C#.
  - **[Bun](https://bun.sh) or any JS bundler:** To bundler Javascript code to one single `.js` file.
  - **[Gleam compiler](https://gleam.run/command-line-reference):** To compiler all the epic codes you write.
{% endif %}

{% if lang == 'vi' %}
  D·ª± √°n Glodot s·∫Ω c√≥ c·∫•u tr√∫c files nh∆∞ sau:
{% else %}
  Your Glodot files structure should look like this:
{% endif %}

```
.  {% if lang == 'vi' %}(Root c·ªßa Godot project){% else %}(Root of Godot project){% endif %}
‚îú‚îÄ‚îÄ core  {% if lang == 'vi' %}(Root c·ªßa Gleam package){% else %}(Root of Gleam package){% endif %}
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ gleam.toml
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ manifest.toml
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ package.json
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ core
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ core.gleam  {% if lang == 'vi' %}(File ch·ª©a t·∫•t c·∫£ c√°c function c·∫ßn truy c·∫≠p t·ª´ ngo√†i Gleam){% else %}(The file that contains all functions to be accessible from outside Gleam){% endif %}
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ project.godot
‚îú‚îÄ‚îÄ project.csproj
‚îú‚îÄ‚îÄ core.txt  {% if lang == 'vi' %}(Code Gleam-ra-JS ƒë√£ ƒë∆∞·ª£c bundle){% else %}(Bundled Gleam-to-JS code){% endif %}
‚îú‚îÄ‚îÄ core.gd  {% if lang == 'vi' %}(Util ƒë·ªÉ ch·∫°y code ƒë√£ bundle trong Godot){% else %}(Util to execute bundled code in Godot){% endif %}
‚îî‚îÄ‚îÄ V8.cs  {% if lang == 'vi' %}(Util ƒë·ªÉ ch·∫°y JS trong Godot){% else %}(Util to execute JS code in Godot){% endif %}
```

### {% if lang == 'vi' %}Ph√≠a Gleam{% else %}Gleam side{% endif %}

{% if lang == 'vi' %}
  ƒê·∫ßu ti√™n, t·∫°o m·ªôt package Gleam b√™n trong root c·ªßa d·ª± √°n Godot:
{% else %}
  First create a Gleam package inside your Godot project's root:
{% endif %}

```sh
gleam new core # {% if lang == 'vi' %}Kh√¥ng nh·∫•t thi·∫øt ph·∫£i t√™n l√† `core`, ƒë·ªÉ t√™n l√† g√¨ c≈©ng ƒë∆∞·ª£c.{% else %}It's could be named anything.{% endif %}
```

{% if lang == 'vi' %}
  R·ªìi vi·∫øt c√°c functions domain logic. Khi xong, t·∫°o m·ªôt file duy nh·∫•t ch·ª©a t·∫•t c·∫£ c√°c h√†m ƒë·ªÉ c√≥ th·ªÉ truy c·∫≠p t·ª´ b√™n ngo√†i Gleam (ƒë·∫∑t t√™n l√† `core.gleam`):
{% else %}
  Then write your domain logic stuffs here. When you done, make a signle file that contains all functions to be accessible from outside of Gleam (name it `core.gleam`):
{% endif %}

```rust
import core/a_stuffs
import core/b_stuffs

pub fn fn_a(input: String) -> String {
  a_stuffs.fn_a(input)
}

pub fn fn_b(input: String) -> String {
  b_stuffs.fn_b(input)
}

// ...
```

{% if lang == 'vi' %}
  ‚ö†Ô∏è C·∫¢NH B√ÅO! C·∫¢NH B√ÅO L·ªöN! custom Type b√™n trong Gleam kh√¥ng th·ªÉ ƒë∆∞·ª£c truy c·∫≠p t·ª´ b√™n ngo√†i, √≠t ra th√¨ n√≥ kh√¥ng h√†nh x·ª≠ nh∆∞ ta mong mu·ªën ƒë√¢u. Ch·ªâ c√≥ `Int`, `Float` v√† `String` l√† c√≥ th·ªÉ d√πng ƒë∆∞·ª£c th√¥i. Th·∫≠m ch√≠ `List` v√† `Dict` c≈©ng kh√¥ng ph·∫£i l√† Array v√† Object c·ªßa JS. T·ªët h∆°n h·∫øt l√† n√™n b·ªçc input v√† output th√†nh string JSON ƒë·ªÉ c√≥ th·ªÉ x·ª≠ l√Ω.
{% else %}
  ‚ö†Ô∏è WARNING! BIG WARNING! You cannot use custom Gleam type as input/output outside of Gleam, at least it's not behaved as you thinks. You can only use `Int`, `Float` and `String`. Even `List` and `Dict` is not the same as JS's Array and Object. The best solution is to warp input and output as JSON string.
{% endif %}

{% if lang == 'vi' %}
  Sau khi vi·∫øt Gleam code ƒë·ªÉ c√≥ th·ªÉ ch·∫°y t·ª´ Godot xong, h√£y ƒë·∫£m b·∫£o l√† m√¨nh ƒë·∫∑t target c·ªßa package l√† JS trong config `gleam.toml`:
{% else %}
  So after you write you fancy code in a Gleam package for your game, make sure to set the target to JS in the `gleam.toml` config file:
{% endif %}

```diff
  name = "core"
  version = "1.0.0"
+ target = "javascript"

...
```

{% if lang == 'vi' %}
  R·ªìi bundler code JS sau m·ªói l·∫ßn compiler:
{% else %}
  Then bundler the JS codes after each time you compiler:
{% endif %}

```sh
cd ./core
bun build ./build/dev/javascript/core/core/core.mjs --outfile ../core.txt
```

{% if lang == 'vi' %}
  ƒê√∫ng v·∫•y, ƒë·ªÉ ƒëu√¥i c·ªßa file n√≥ l√† `.txt` ch·ª© kh√¥ng ph·∫£i `.js` ƒë·ªÉ Godot c√≥ th·ªÉ nh·∫≠n d·∫°ng l√† file ch·ªØ v√† ƒë·ªçc n·ªôi dung b√™n trong ƒë·∫•y.
{% else %}
  Yep it's end with `.txt` so that Godot can detect and read the texts inside that file.
{% endif %}

{% if lang == 'vi' %}
  V√† h√£y nh·ªõ b·ªè ph·∫ßn `export` b√™n trong file ƒë√£ bundle ƒë·ªÉ V8 kh√¥ng b√°o l·ªói.
{% else %}
  And remember to remove the `export` part inside the bundled file so that V8 don't warning.
{% endif %}

### {% if lang == 'vi' %}Ph√≠a Godot{% else %}Godot side{% endif %}

{% if lang == 'vi' %}
  ƒê·∫ßu ti√™n c√†i [ClearScript](https://github.com/Microsoft/ClearScript) trong m√°y:
{% else %}
  First install [ClearScript](https://github.com/Microsoft/ClearScript) to your system:
{% endif %}

```sh
nuget install Microsoft.ClearScript.Complete
```

{% if lang == 'vi' %}
  Sau ƒë·∫•y th√™m n√≥ v√†o `project.csproj`:
{% else %}
  Then add it to the `project.csproj` file:
{% endif %}

```diff
  <Project Sdk="Godot.NET.Sdk/4.4.1">
    <PropertyGroup>
      <TargetFramework>net8.0</TargetFramework>
      <EnableDynamicLoading>true</EnableDynamicLoading>
      <RootNamespace>project</RootNamespace>
    </PropertyGroup>
+   <ItemGroup>
+     <PackageReference Include="Microsoft.ClearScript.Complete" Version="7.5.0" />
+   </ItemGroup>
  </Project>
```

{% if lang == 'vi' %}
  Vi·∫øt m·ªôt util t√™n l√† `V8.cs` ƒë·ªÉ ch·∫°y code JS:
{% else %}
  Write an util name `V8.cs` in your project to execute JS code:
{% endif %}

```cs
using Godot;
using System;
using Microsoft.ClearScript.V8;

public partial class V8 : Node
{
    private static V8ScriptEngine _engine = new V8ScriptEngine();

    public static string eval(string code)
    {
        return Convert.ToString(_engine.Evaluate(code));
    }
}
```

{% if lang == 'vi' %}
  Cu·ªëi c√πng, t·∫°o m·ªôt util ƒë·ªÉ ch·∫°y code Gleam ƒë√£ xu·∫•t v√† bundle (ƒë·∫∑t t√™n file l√† `core.gd` ƒëi cho ƒë·ªìng b·ªô):
{% else %}
  Finally, make an util to execute Gleam-to-JS bundled code (name it `core.gd`):
{% endif %}

```gdscript
extends Node

const _v8 := preload("res://src/V8.cs")


func _ready() -> void:
    var core_file := FileAccess.open(&"res://core.txt", FileAccess.READ)
    var core_code := core_file.get_as_text()
    _v8.eval(core_code)


func fn_a(arg: Variant) -> Variant:
	return _invoke(&"fn_a", arg)


func fn_b(arg: Variant) -> Variant:
	return _invoke(&"fn_b", arg)


func _invoke(funcName: String, argument: Variant) -> Variant:
    var code: Variant = &"{funcName}(\"{argument}\")".format({
        &"funcName": funcName,
        &"argument": JSON.stringify(argument).json_escape(),
    })

    var result: Variant = _v8.eval(code)

    var json := JSON.new()
    var error := json.parse(result)

    if error:
        if result != &"":
            printerr(result)

        return null

    return json.data
```

### {% if lang == 'vi' %}Xu·∫•t ra web{% else %}Export to web{% endif %}

{% if lang == 'vi' %}
  Nh∆∞ ƒë√£ ƒë·ªÅ c·∫≠p trong [doc c·ªßa Godot](https://docs.godotengine.org/en/4.4/tutorials/export/exporting_for_web.html):

  > D·ª± √°n vi·∫øt b·∫±ng C# v·ªõi Godot 4 hi·ªán t·∫°i kh√¥ng th·ªÉ xu·∫•t ra web. ƒê·ªçc [blog n√†y](https://godotengine.org/article/platform-state-in-csharp-for-godot-4-2/#web) ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt.

  Tuy nhi√™n b·∫°n c√≥ th·ªÉ fallback v·ªÅ d√πng [`JavaScriptBridge`](https://docs.godotengine.org/en/stable/tutorials/platform/web/javascript_bridge.html#doc-web-javascript-bridge) ƒë·ªÉ ch·∫°y code JS thay cho C# + ClearScript khi xu·∫•t l√™n web.
{% else %}
  As said in [the Godot document](https://docs.godotengine.org/en/4.4/tutorials/export/exporting_for_web.html):

  > Projects written in C# using Godot 4 currently cannot be exported to the web. See [this blog post](https://godotengine.org/article/platform-state-in-csharp-for-godot-4-2/#web) for more information.

  However you can fallback to use [`JavaScriptBridge`](https://docs.godotengine.org/en/stable/tutorials/platform/web/javascript_bridge.html#doc-web-javascript-bridge) to run JS code instate of C# + ClearScript when export to web.
{% endif %}

### {% if lang == 'vi' %}M·ªôt s·ªë b·ªï sung{% else %}Additional{% endif %}

{% if lang == 'vi' %}
  D∆∞·ªõi ƒë√¢y l√† m·ªôt s·ªë th∆∞ vi·ªán Gleam h∆∞u d·ª•ng cho vi·ªác l√†m game:
{% else %}
  Here are some Gleam libraries that are useful for gamedev:
{% endif %}

- [`gleam_community_maths`](https://hexdocs.pm/gleam_community_maths): {% if lang == 'vi' %}Th∆∞ vi·ªán to√°n c∆° b·∫£n ch·ª©a c√°c functions and utilities to√°n h·ªçc c∆° b·∫£n.{% else %}A basic mathematics library that contains some of the most fundamental mathematics functions and utilities.{% endif %}
- [`prng`](https://hexdocs.pm/prng): {% if lang == 'vi' %}Th∆∞ vi·ªán x·ª≠ l√Ω s·ªë v√† c√°c lo·∫°i th·ª© ng·∫´u nhi√™n PRNG.{% else %}A lib to handle PRNG (Pure Random Number Generator).{% endif %}
- [`vec`](https://hexdocs.pm/vec): {% if lang == 'vi' %}Th∆∞ vi·ªán x·ª≠ l√Ω vectors, c√≥ h·∫ßu h·∫øt c√°c th·ª© c√≥ th·ªÉ l√†m ƒë∆∞·ª£c nh∆∞ trong Godot.{% else %}A vector library, has almost everything that can be done in Godot.{% endif %}
- [`vec_dict`](https://hexdocs.pm/vec_dict): {% if lang == 'vi' %}Th∆∞ vi·ªán n√†y d√πng ƒë·ªÉ th·ªÉ hi·ªán v√† x·ª≠ l√Ω grid 2D, 3D v√† c·∫£ 4D.{% else %}This is to represent and handle a 2D, 3D  and even 4D grid.{% endif %}

### {% if lang == 'vi' %}M·ªôt Glodot kh√°c?{% else %}Alternatives route?{% endif %}

{% if lang == 'vi' %}
  Ph∆∞∆°ng ph√°p Godot Mono - ClearScript ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p ·ªü tr√™n c√≥ v·∫ª kh√° v√≤ng v√®o nh∆∞ng ƒë·∫•y hi·ªán t·∫°i l√† c√°ch "ch√≠nh th·ª©c nh·∫•t". Godot Mono l√† m·ªôt phi√™n b·∫£n ch√≠nh th·ª©c c·ªßa Godot v√† ClearScript l√† th∆∞ vi·ªán c·ªßa Microsoft (nh√† s√°ng l·∫≠p ra C#) ch√≠nh v√¨ th·∫ø n√™n n√≥ kh√° l√† ·ªïn ƒë·ªãnh.

  Glodot _**c√≥ th·ªÉ**_ ƒë∆∞·ª£c th·ª±c thi ƒë∆∞·ª£c b·∫±ng c√°ch D√πng [GodotJS](https://godotjs.github.io) ƒë·ªÉ thay th·∫ø cho c√°ch tr√™n, N·ªëi t·ª´ Godot ƒë·∫øn Gleam code ƒë√£ ƒë∆∞·ª£c complie ch·ªâ qua JS/TS.

  Tuy nhi√™n ·ªü th·ªùi ƒëi·ªÉm ƒë√£ vi·∫øt b√†i vi·∫øt n√†y GodotJS kh√° l√† buggy/janky, m√¨nh mong l√† n√≥ c√≥ th·ªÉ tr·ªü n√™n t·ªët h∆°n v√¨ n·∫øu GodotJS tr·ªü n√™n ·ªïn ƒë·ªãnh v√† c√†i ƒë·∫∑t ti·ªán ƒë∆∞·ª£c nh∆∞ Godot Mono th√¨ ƒë·∫•y s·∫Ω l√† m·ªôt c√°ch r·∫•t l√Ω t∆∞·ªüng.

  M√† ƒë∆∞·ª£c voi d√≤i ti√™n, m√¨nh ∆∞·ªõc l√† c√≥ m·ªôt c√°i Godot plugin m√† c√≥ th·ªÉ t·ª± complie package Gleam ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh r·ªìi cho m·ªôt c√°i API ƒë·ªÉ d·ªÖ d√†ng ch·∫°y n√≥.
{% else %}
  The Godot Mono - ClearScript route mentioned above seems quite roundabout, but it's currently the most "official" way. Godot Mono is an official version of Godot, and ClearScript is a library from Microsoft (the creator of C#), make this approach quite stable.

  Glodot _**could**_ potentially be made by using [GodotJS](https://godotjs.github.io) to replace the route above, connecting Godot to compiled Gleam code purely through JS/TS.

  But that is a shortcut, because at the time of writing, GodotJS is quite buggy/janky. I hope it will improve soon, because if GodotJS becomes as stable and easy to set up as Godot Mono, it would be an ideal method.

  But if I could wish, I want a Godot plugin that could automatically compile a specified Gleam package and then provide an API to easily run it.
{% endif %}

_Well that's all fork, stay gleamy~!_
